//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"

#import <Foundation/Foundation.h>
#import <AppKit/AppKit.h>
#import <OpenGL/OpenGL.h>
#import <dispatch/queue.h>

// general includes
#include <stdio.h>
#include <limits.h>

void (*xChuck_UI_Manager_start)() = NULL;

class chugl
{
public:
    static chugl *instance()
    {
        if(s_instance == NULL)
            s_instance = new chugl();
        return s_instance;
    }
    
    void openWindow(float width, float height)
    {
        dispatch_sync(dispatch_get_main_queue(), ^{
            NSWindow *window = [[NSWindow alloc] initWithContentRect:NSMakeRect(0, 0, width, height)
                styleMask:NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask
                backing:NSBackingStoreBuffered
                defer:NO];
            [window center];
            [window makeKeyAndOrderFront:nil];
            
            NSOpenGLView *glView = [[NSOpenGLView alloc] initWithFrame:[[window contentView] bounds]];
            [[window contentView] addSubview:glView];
            
            m_ctx = [glView openGLContext];
            m_windowWidth = width;
            m_windowHeight = height;
        });
    }
    
    void glEnter()
    {
        if(!m_enter)
        {
            CGLLockContext((CGLContextObj)[m_ctx CGLContextObj]);
            [m_ctx makeCurrentContext];
        }
        
        m_enter = true;
    }
    
    void glExit()
    {
        CGLUnlockContext((CGLContextObj)[m_ctx CGLContextObj]);
        m_enter = false;
    }
    
    t_CKFLOAT windowWidth() { return m_windowWidth; }
    t_CKFLOAT windowHeight() { return m_windowHeight; }
    
private:
    static chugl *s_instance;
    
    NSOpenGLContext *m_ctx;
    bool m_enter;
    t_CKFLOAT m_windowWidth, m_windowHeight;
    
    chugl()
    {
        xChuck_UI_Manager_start = (void (*)()) dlsym(RTLD_DEFAULT, "Chuck_UI_Manager_start");
        if(xChuck_UI_Manager_start != NULL)
            xChuck_UI_Manager_start();
        // else fuck it we'll do it live
        // TODO: check if in miniAudicle; otherwise log warning
        
        m_enter = false;
        m_windowWidth = m_windowHeight = 0;
    }
};

void chuglEnter() { chugl::instance()->glEnter(); }
void chuglExit() { chugl::instance()->glExit(); }

template<typename T>
T rad2deg(T rad)
{
    return rad/M_PI*180.0;
}


chugl *chugl::s_instance = NULL;

// example of getter/setter
CK_DLL_SFUN(chugl_openWindow)
{
    t_CKFLOAT x = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT y = GET_NEXT_FLOAT(ARGS);
    
    chugl::instance()->openWindow(x, y);
}

CK_DLL_SFUN(chugl_beginDraw)
{
    chuglEnter();
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, chugl::instance()->windowWidth(), 0, chugl::instance()->windowHeight(), -0.1, 100);
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    chuglExit();
}

CK_DLL_SFUN(chugl_endDraw)
{
    chuglEnter();
    
    glFlush();
    
    chuglExit();
}

CK_DLL_SFUN(chugl_color4)
{
    t_CKFLOAT r = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT g = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT b = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT a = GET_NEXT_FLOAT(ARGS);
    
    chuglEnter();
    
    glColor4f(r, g, b, a);
    
    chuglExit();
}

CK_DLL_SFUN(chugl_translate2)
{
    t_CKFLOAT x = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT y = GET_NEXT_FLOAT(ARGS);
    
    chuglEnter();
    
    glTranslatef(x, y, 0);
    
    chuglExit();
}

CK_DLL_SFUN(chugl_rotateZ)
{
    t_CKFLOAT z = GET_NEXT_FLOAT(ARGS);
    
    chuglEnter();
    
    glRotatef(rad2deg(z), 0, 0, 1);
    
    chuglExit();
}

CK_DLL_SFUN(chugl_rect)
{
    t_CKFLOAT x = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT y = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT width = GET_NEXT_FLOAT(ARGS);
    t_CKFLOAT height = GET_NEXT_FLOAT(ARGS);
    
    chuglEnter();
    
    glBegin(GL_TRIANGLE_STRIP);
    glVertex3f(x, y, 0);
    glVertex3f(x+width, y, 0);
    glVertex3f(x, y+height, 0);
    glVertex3f(x+width, y+height, 0);
    glEnd();
    
    chuglExit();
}

CK_DLL_SFUN(chugl_clear)
{
    chuglEnter();
    
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    chuglExit();
}


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( chugl )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "chugl");
    
    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "gfx", "Object");
    
    QUERY->add_sfun(QUERY, chugl_openWindow, "void", "openWindow");
    QUERY->add_arg(QUERY, "float", "width");
    QUERY->add_arg(QUERY, "float", "height");
    
    QUERY->add_sfun(QUERY, chugl_beginDraw, "void", "beginDraw");
    
    QUERY->add_sfun(QUERY, chugl_endDraw, "void", "endDraw");
    
    QUERY->add_sfun(QUERY, chugl_clear, "void", "clear");
    
    QUERY->add_sfun(QUERY, chugl_rotateZ, "void", "rotate");
    QUERY->add_arg(QUERY, "float", "z");
    
    QUERY->add_sfun(QUERY, chugl_translate2, "void", "translate");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    
    QUERY->add_sfun(QUERY, chugl_color4, "void", "color");
    QUERY->add_arg(QUERY, "float", "r");
    QUERY->add_arg(QUERY, "float", "g");
    QUERY->add_arg(QUERY, "float", "b");
    QUERY->add_arg(QUERY, "float", "a");
    
    QUERY->add_sfun(QUERY, chugl_rect, "void", "rect");
    QUERY->add_arg(QUERY, "float", "x");
    QUERY->add_arg(QUERY, "float", "y");
    QUERY->add_arg(QUERY, "float", "width");
    QUERY->add_arg(QUERY, "float", "height");
    
    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}



